# 导线交互 BUG 系统审计设计

Date: 2026-02-27  
Project: `HighSchoolCircuitSimulation`  
Scope: 导线交互专项（桌面鼠标 + 触屏 + 触控笔）

## 1. 目标与边界

本设计不直接修改交互行为，目标是先建立一套可复现、可分级、可回归的导线交互缺陷审计体系，并输出可排期修复的 `Top 20` 缺陷清单。

本轮仅覆盖导线主链路：

1. 建线入口（工具模式、空白处起线、端子起线）
2. 吸附判定（端子/导线端点/导线段/网格）
3. 拖拽与释放（端点拖拽、整体拖拽、mouseup/mouseleave）
4. 视图变换影响（缩放、平移）
5. 输入设备切换（mouse/touch/pen）
6. 拓扑提交与视觉反馈（`compactWires`、`rebuildNodes`、高亮/刷新）

非目标：

1. 求解器数值模型优化
2. 元器件物理属性变更
3. 与导线无关的面板/UI 美术调整

## 2. 方案对比与推荐

### 方案 A：人工探索优先

优点：快速抓到“手感类”问题。  
缺点：覆盖不稳定，难以长期防回归。

### 方案 B：自动化优先

优点：回归强。  
缺点：前期搭建成本高，难捕捉全部交互细节。

### 方案 C：混合方案（推荐）

先用结构化人工探索产出 `Top 20`，每条都具备证据和分级；再把 `P0/P1` 高风险问题转为自动化回归。

推荐理由：

1. 最快满足“可修复问题台账”
2. 同时建立后续防回归基础
3. 风险和投入比最优

## 3. 审计架构与数据流

### 3.1 审计架构

采用“场景分层 + 证据模板 + 风险分级”三段式：

1. `L1 基础连线`：端子到端子、端子到导线端点、自由点到自由点
2. `L2 变换干扰`：`scale(0.5/1/2/4)` + 画布平移边缘场景
3. `L3 复杂交互`：端点拖拽、多分支汇合、pointer 类型切换、菜单冲突

### 3.2 缺陷定位数据流

每条缺陷必须绑定同一条定位链：

`输入事件 -> 坐标变换(screenToCanvas) -> 吸附判定(snapPoint/findNearby*) -> 交互状态机(isWiring/isDragging*) -> 拓扑提交(compact/rebuild) -> 渲染反馈(highlight/refresh)`

该链用于区分“现象层问题”和“根因层问题”，避免只报体验不报定位。

### 3.3 根因分类（强制五选一）

1. 坐标域错配
2. 阈值策略不一致
3. 状态机竞态
4. 提交时机错误
5. 视觉与实际脱节

## 4. 系统化扫描矩阵

### 4.1 矩阵维度

1. 输入设备：`mouse` / `touch` / `pen`
2. 视图变换：`scale(0.5/1/2/4)` + `pan(中心/边缘)`
3. 连线阶段：`起点选择` / `预览吸附` / `终点释放` / `端点二次拖拽`
4. 目标类型：`terminal` / `wire-endpoint` / `wire-segment` / `grid`
5. 状态切换：`单指->双指->单指恢复`、`pen->mouse`、`长按菜单后继续连线`

### 4.2 执行顺序

1. `P0 候选`：缩放后吸附、误连、释放后拓扑错误
2. `P1 候选`：触屏/触控笔阈值漂移、命中区与吸附点不一致
3. `P2/P3`：高亮残留、状态清理、低频边缘条件

### 4.3 优先级分值

`Score = Impact(1-5) × Frequency(1-5) × Unavoidable(1-3)`

准入规则：

1. `Score >= 45`：进入 `Top 20`
2. `25 <= Score < 45`：进入候补池
3. `< 25`：仅记录，不进本轮主交付

## 5. 交付物设计

## 5.1 Top 20 主清单字段（必填）

每条编号 `WIR-###`，字段如下：

1. `id`
2. `title`
3. `device`（mouse/touch/pen）
4. `viewport_state`（scale/pan）
5. `steps`（最少 3 步）
6. `expected`
7. `actual`
8. `root_cause_class`
9. `severity`（P0-P3）
10. `score`
11. `impact_scope`
12. `suggested_fix_location`（文件/函数）
13. `auto_test_status`（none/planned/covered）

## 5.2 候补池

记录所有未入 Top20 但可复现的问题，保持相同字段结构，便于下轮继承。

## 5.3 自动化映射表

用于追踪“缺陷 -> 测试”关系，字段建议：

1. `wir_id`
2. `test_level`（unit/integration/e2e）
3. `test_file`
4. `status`
5. `notes`

## 6. 测试策略

### 6.1 单元层（判定逻辑）

优先覆盖：

1. `SnapController`（阈值、优先级、设备差异）
2. `WireInteractions`（端点/线段判定、排除集合）
3. `InteractionOrchestrator`（事件入口与状态切换）

### 6.2 集成层（状态收敛）

覆盖：

1. pointer 会话切换（mouse/touch/pen）
2. 缩放 + 连线组合行为
3. `mouseup/mouseleave/pointercancel` 后的状态与拓扑一致性

### 6.3 回归门槛

1. `Top20` 中 `P0/P1` 问题必须至少各有 1 条自动化用例
2. 每修复一条高风险缺陷，必须补或增强对应回归测试

## 7. 两周执行节奏

1. D1-D2：矩阵扫查，冻结 `Top20` 草案
2. D3-D5：补证据与根因定位，去除不可稳定复现项
3. D6-D8：将高风险项映射为自动化用例
4. D9-D10：复盘、重排优先级、输出修复建议版

## 8. 验收标准

1. `Top20` 每条可在干净环境稳定复现
2. 至少 8 条已映射到自动化回归
3. 每条都有明确修复位点（文件+函数）
4. 交付可直接进入修复排期，无需二次定义

## 9. 风险与缓解

1. 风险：手感类问题复现不稳定  
缓解：固定设备、固定缩放、固定路径录屏与事件日志同步。

2. 风险：低频缺陷挤占 Top20  
缓解：强制按分值准入，主清单只保留高价值问题。

3. 风险：问题描述与根因脱节  
缓解：强制填写定位链与根因五选一。

---

如果继续实施，下一步是进入实现计划阶段：把本设计转成可执行任务拆分与测试清单。
